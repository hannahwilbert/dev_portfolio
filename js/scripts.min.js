!(function(n) {
  n("html").removeClass("no-js"),
    n("header a").click(function(e) {
      if (!n(this).hasClass("no-scroll")) {
        e.preventDefault();
        var t = n(this).attr("href"),
          i = n(t).offset().top;
        n("html, body").animate(
          { scrollTop: i + "px" },
          Math.abs(window.pageYOffset - n(t).offset().top) / 1
        ),
          n("header").hasClass("active") &&
            n("header, body").removeClass("active");
      }
    }),
    n("#to-top").click(function() {
      n("html, body").animate({ scrollTop: 0 }, 500);
    }),
    n("#lead-down span").click(function() {
      var e = n("#lead")
        .next()
        .offset().top;
      n("html, body").animate({ scrollTop: e + "px" }, 500);
    }),
    n("#experience-timeline").each(function() {
      ($this = n(this)),
        ($userContent = $this.children("div")),
        $userContent.each(function() {
          n(this)
            .addClass("vtimeline-content")
            .wrap(
              '<div class="vtimeline-point"><div class="vtimeline-block"></div></div>'
            );
        }),
        $this.find(".vtimeline-point").each(function() {
          n(this).prepend(
            '<div data-aos="fade-up" data-aod-duration="3000"> <div class="vtimeline-icon"><i class="fa fa-map-marker"></i></div></div>'
          );
        }),
        $this.find(".vtimeline-content").each(function() {
          var e = n(this).data("date");
          e &&
            n(this)
              .parent()
              .prepend('<span class="vtimeline-date">' + e + "</span>");
        });
    }),
    n("#mobile-menu-open").click(function() {
      n("header, body").addClass("active");
    }),
    n("#mobile-menu-close").click(function() {
      n("header, body").removeClass("active");
    }),
    n("#view-more-projects").click(function(e) {
      e.preventDefault(),
        n(this).fadeOut(300, function() {
          n("#more-projects").fadeIn(300);
        });
    });
})(jQuery);

/* user defined variables */
var timeOnSlide = 3,
  // the time each image will remain static on the screen, measured in seconds
  timeBetweenSlides = 1,
  // the time taken to transition between images, measured in seconds

  // test if the browser supports animation, and if it needs a vendor prefix to do so
  animationstring = "animation",
  animation = false,
  keyframeprefix = "",
  domPrefixes = "Webkit Moz O Khtml".split(" "),
  // array of possible vendor prefixes
  pfx = "",
  slidy = document.getElementById("slidy");
if (slidy.style.animationName !== undefined) {
  animation = true;
}
// browser supports keyframe animation w/o prefixes

if (animation === false) {
  for (var i = 0; i < domPrefixes.length; i++) {
    if (slidy.style[domPrefixes[i] + "AnimationName"] !== undefined) {
      pfx = domPrefixes[i];
      animationstring = pfx + "Animation";
      keyframeprefix = "-" + pfx.toLowerCase() + "-";
      animation = true;
      break;
    }
  }
}

if (animation === false) {
  // animate in JavaScript fallback
} else {
  var images = slidy.getElementsByTagName("img"),
    firstImg = images[0],
    // get the first image inside the "slidy" element.
    imgWrap = firstImg.cloneNode(false); // copy it.
  slidy.appendChild(imgWrap); // add the clone to the end of the images
  var imgCount = images.length, // count the number of images in the slide, including the new cloned element
    totalTime = (timeOnSlide + timeBetweenSlides) * (imgCount - 1), // calculate the total length of the animation by multiplying the number of _actual_ images by the amount of time for both static display of each image and motion between them
    slideRatio = (timeOnSlide / totalTime) * 100, // determine the percentage of time an induvidual image is held static during the animation
    moveRatio = (timeBetweenSlides / totalTime) * 100, // determine the percentage of time for an individual movement
    basePercentage = 100 / imgCount, // work out how wide each image should be in the slidy, as a percentage.
    position = 0, // set the initial position of the slidy element
    css = document.createElement("style"); // start marking a new style sheet
  css.type = "text/css";
  css.innerHTML +=
    "#slidy { text-align: left; margin: 0; font-size: 0; position: relative; width: " +
    imgCount * 100 +
    "%;  }\n"; // set the width for the slidy container
  css.innerHTML +=
    "#slidy img { float: left; width: " + basePercentage + "%; }\n";
  css.innerHTML += "@" + keyframeprefix + "keyframes slidy {\n";
  for (i = 0; i < imgCount - 1; i++) {
    //
    position += slideRatio; // make the keyframe the position of the image
    css.innerHTML += position + "% { left: -" + i * 100 + "%; }\n";
    position += moveRatio; // make the postion for the _next_ slide
    css.innerHTML += position + "% { left: -" + (i + 1) * 100 + "%; }\n";
  }
  css.innerHTML += "}\n";
  css.innerHTML +=
    "#slidy { left: 0%; " +
    keyframeprefix +
    "transform: translate3d(0,0,0); " +
    keyframeprefix +
    "animation: " +
    totalTime +
    "s slidy infinite; }\n"; // call on the completed keyframe animation sequence
  document.body.appendChild(css); // add the new stylesheet to the end of the document
}

// wavey text

$().ready(function() {
  var $e = $("#wave-text");
  wavify($e, -0.2, 12);
});

function wavify($e, delay, period) {
  var content = $e.text();
  var result = "";

  for (var i in content) {
    var c = content[i];
    var s = "";

    if (c == " ") {
      s = "&nbsp;";
    } else {
      var $span = $("<span>")
        .addClass("w")
        .text(c);

      var t = parseFloat(i % period);
      var dt = (1.0 + t) * delay;
      $span.css("-webkit-animation-delay", dt + "s");
      s = $span[0].outerHTML;
    }

    result += s;
  }

  $e.html(result);
}

// BUBBLE SHOOTER

window.requestAnimFrame =
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  function(callback) {
    window.setTimeout(callback, 4);
  };

function Bubble(left, top, num) {
  this.left = left;
  this.top = top;
  this.xAccel = 0;
  this.yAccel = 0;
  this.width = 20;
  this.height = 20;

  this.div = '<div class="bubble" id="bubble-' + num + '"></div>';
  this.cl = ".bubble";
  this.id = "#bubble-" + num;
  this.effect = "wobble";
}

var bubbleNum = 0;

function wobble(ele) {
  ele.addClass("wobble");

  setTimeout(function() {
    ele.removeClass("wobble");
  }, 500);
}

function createBubble() {
  var randY = Math.floor(Math.random() * 8 - 4);
  var randX = Math.floor(Math.random() * 1000);
  var b = new Bubble(50, 50, bubbleNum);
  var that = null;
  var trajX = 5;
  var trajY = randY;
  var curLeft = b.left;
  var curTop = b.top;
  var boundX = $(document).width() - 312;
  var boundY = $(document).height() - 118;

  $(b.div)
    .appendTo(".barrel")
    .css({
      top: b.top + "px",
      left: b.left + "px"
    });

  bubbleNum++;

  var $thisBubble = $(b.id);

  wobble($thisBubble);

  var inc = 0;
  var movingR = true;
  var movingD;
  // Array containing colors

  randY <= 0 ? (movingD = false) : (movingD = true);

  function floatAround() {
    $thisBubble.css({
      left: curLeft + "px"
    });

    movingR ? (curLeft = curLeft + trajX) : (curLeft = curLeft - trajX);

    if (curLeft > boundX && movingR) {
      wobble($thisBubble);
    } else if (curLeft < -312 && !movingR) {
      movingR = true;
      wobble($thisBubble);
    }

    if (bubbleNum == inc++) {
      $thisBubble.css({
        background: "#c44e9d"
      });
    }

    if (inc == 50) {
      $thisBubble.css({
        zIndex: "10"
      });
    }

    if (inc % 3 == 0) {
      $thisBubble.css({
        top: curTop + "px"
      });

      if (curTop > boundY && movingD) {
        movingD = false;
        wobble($thisBubble);
      } else if (curTop < -90 && !movingD) {
        movingD = true;
        wobble($thisBubble);
      }

      if (randY <= 0 && movingD) {
        curTop = curTop - trajY;
      } else if (randY > 0 && movingD) {
        curTop = curTop + trajY;
      } else if (randY <= 0 && !movingD) {
        curTop = curTop + trajY;
      } else if (randY > 0 && !movingD) {
        curTop = curTop - trajY;
      }
    }

    inc++;
    requestAnimFrame(floatAround);
  }
  requestAnimFrame(floatAround);

  /*  var floating = setInterval(function() {
    
  }, 8)*/
}

$(document).ready(function() {
  var barrel;
  var bubbleNum = 0;

  $(".barrel").on("mousedown touchstart", function(e) {
    e.preventDefault();

    $(".barrel h2").fadeOut(300);

    $(".barrel").addClass("shoot");

    handle = setInterval(function() {
      createBubble();
    }, 200);
  });

  $(".barrel").on("mouseup touchend", function() {
    $(".barrel").removeClass(".shoot");

    clearInterval(handle);
    handle = null;
  });

  $("body").on("click touchstart", ".bubble", function() {
    $this = $(this);
    $this.addClass("pop");

    setTimeout(function() {
      $this.remove();
    }, 100);
  });
});

// subscroll

var isScrolling;

// Listen for scroll events
window.addEventListener(
  "scroll",
  function() {
    $(".wingg").css({
      animation: "rotate .5s infinite linear"
    });
    $(".bubblee").css({
      opacity: "100%",
      transform: "scale(1.9)"
    });

    // Clear our timeout throughout the scroll
    window.clearTimeout(isScrolling);

    // Set a timeout to run after scrolling ends
    isScrolling = setTimeout(function() {
      // Run the callback

      $(".wingg").css({
        animation: "rotate 0s infinite linear"
      });
      $(".bubblee").css({
        opacity: "60%"
      });

      console.log("Scrolling has stopped.");
    }, 66);
  },
  false
);

function onVisible(element, callback) {
  new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.intersectionRatio > 0) {
        callback(element);
        observer.disconnect();
        $(".submarine").css({
          top: "1400px",
          transition: "all 5s"
        });
      }
    });
  }).observe(element);
}

onVisible(document.querySelector("#footer"), () => console.log("it's visible"));

function myFunction(x) {
  if (x.matches) {
    // If media query matches
  }
}

var x = window.matchMedia("(max-width: 480px)");
myFunction(x); // Call listener function at run time
x.addListener(myFunction); // Attach listener function on state changes
