/*!
    Title: Dev Portfolio Template
    Version: 1.2.1
    Last Change: 08/27/2017
    Author: Ryan Fitzgerald
    Repo: https://github.com/RyanFitzgerald/devportfolio-template
    Issues: https://github.com/RyanFitzgerald/devportfolio-template/issues

    Description: This file contains all the scripts associated with the single-page
    portfolio website.
*/
!(function(n) {
  n("html").removeClass("no-js"),
    n("header a").click(function(e) {
      if (!n(this).hasClass("no-scroll")) {
        e.preventDefault();
        var t = n(this).attr("href"),
          i = n(t).offset().top;
        n("html, body").animate(
          { scrollTop: i + "px" },
          Math.abs(window.pageYOffset - n(t).offset().top) / 1
        ),
          n("header").hasClass("active") &&
            n("header, body").removeClass("active");
      }
    }),
    n("#to-top").click(function() {
      n("html, body").animate({ scrollTop: 0 }, 500);
    }),
    n("#lead-down span").click(function() {
      var e = n("#lead")
        .next()
        .offset().top;
      n("html, body").animate({ scrollTop: e + "px" }, 500);
    }),
    n("#experience-timeline").each(function() {
      ($this = n(this)),
        ($userContent = $this.children("div")),
        $userContent.each(function() {
          n(this)
            .addClass("vtimeline-content")
            .wrap(
              '<div class="vtimeline-point"><div class="vtimeline-block"></div></div>'
            );
        }),
        $this.find(".vtimeline-point").each(function() {
          n(this).prepend(
            '<div data-aos="fade-up" data-aod-duration="3000"> <div class="vtimeline-icon"><i class="fa fa-map-marker"></i></div></div>'
          );
        }),
        $this.find(".vtimeline-content").each(function() {
          var e = n(this).data("date");
          e &&
            n(this)
              .parent()
              .prepend('<span class="vtimeline-date">' + e + "</span>");
        });
    }),
    n("#mobile-menu-open").click(function() {
      n("header, body").addClass("active");
    }),
    n("#mobile-menu-close").click(function() {
      n("header, body").removeClass("active");
    }),
    n("#view-more-projects").click(function(e) {
      e.preventDefault(),
        n(this).fadeOut(300, function() {
          n("#more-projects").fadeIn(300);
        });
    });
})(jQuery);


/* user defined variables */
var timeOnSlide = 3, 		
    // the time each image will remain static on the screen, measured in seconds
timeBetweenSlides = 1, 	
    // the time taken to transition between images, measured in seconds

// test if the browser supports animation, and if it needs a vendor prefix to do so
    animationstring = 'animation',
    animation = false,
    keyframeprefix = '',
    domPrefixes = 'Webkit Moz O Khtml'.split(' '), 
    // array of possible vendor prefixes
    pfx  = '',
    slidy = document.getElementById("slidy"); 
if (slidy.style.animationName !== undefined) { animation = true; } 
// browser supports keyframe animation w/o prefixes

if( animation === false ) {
  for( var i = 0; i < domPrefixes.length; i++ ) {
    if( slidy.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
      pfx = domPrefixes[ i ];
      animationstring = pfx + 'Animation';
      keyframeprefix = '-' + pfx.toLowerCase() + '-';
      animation = true;
      break;
    }
  }
}

if( animation === false ) {
  // animate in JavaScript fallback
} else {
  var images = slidy.getElementsByTagName("img"),
      firstImg = images[0], 
      // get the first image inside the "slidy" element.
      imgWrap = firstImg.cloneNode(false);  // copy it.
  slidy.appendChild(imgWrap); // add the clone to the end of the images
  var imgCount = images.length, // count the number of images in the slide, including the new cloned element
      totalTime = (timeOnSlide + timeBetweenSlides) * (imgCount - 1), // calculate the total length of the animation by multiplying the number of _actual_ images by the amount of time for both static display of each image and motion between them
      slideRatio = (timeOnSlide / totalTime)*100, // determine the percentage of time an induvidual image is held static during the animation
      moveRatio = (timeBetweenSlides / totalTime)*100, // determine the percentage of time for an individual movement
      basePercentage = 100/imgCount, // work out how wide each image should be in the slidy, as a percentage.
      position = 0, // set the initial position of the slidy element
      css = document.createElement("style"); // start marking a new style sheet
  css.type = "text/css";
  css.innerHTML += "#slidy { text-align: left; margin: 0; font-size: 0; position: relative; width: " + (imgCount * 100) + "%;  }\n"; // set the width for the slidy container
  css.innerHTML += "#slidy img { float: left; width: " + basePercentage + "%; }\n";
  css.innerHTML += "@"+keyframeprefix+"keyframes slidy {\n"; 
  for (i=0;i<(imgCount-1); i++) { // 
    position+= slideRatio; // make the keyframe the position of the image
    css.innerHTML += position+"% { left: -"+(i * 100)+"%; }\n";
    position += moveRatio; // make the postion for the _next_ slide
    css.innerHTML += position+"% { left: -"+((i+1) * 100)+"%; }\n";
}
  css.innerHTML += "}\n";
  css.innerHTML += "#slidy { left: 0%; "+keyframeprefix+"transform: translate3d(0,0,0); "+keyframeprefix+"animation: "+totalTime+"s slidy infinite; }\n"; // call on the completed keyframe animation sequence
document.body.appendChild(css); // add the new stylesheet to the end of the document
}








// bubbles mousefollow 

// window.requestAnimFrame = (function(callback) {
//   return window.requestAnimationFrame ||
//     window.webkitRequestAnimationFrame ||
//     window.mozRequestAnimationFrame ||
//     window.oRequestAnimationFrame ||
//     window.msRequestAnimationFrame ||
//     function(callback) {
//       window.setTimeout(callback, 1000 / 60);
//     };
// })();

// // output is in the range of [0, 1]
// // t is the elapsed time and d is the duration
// Math.linearInOut = function(t, d) {
//   if (t > d / 2) {
//     return 2 - (t / (d / 2));
//   } else {
//     return t / (d / 2);
//   }
// }

// window.onload = function() {
//   DoCanvasEffect('canvas');
// }




// function DoCanvasEffect(canvas_id){

//   // scene options:
//   var follow = true;
//   var follow_opacity = true;
//   var speed = .10;

//   var canvas = document.getElementById(canvas_id);
//   var dt = 16.667;

//   //Make the canvas occupy the full page
//   var W = window.innerWidth;
//    var H = window.innerHeight;
//   canvas.width = W ;
//   canvas.height = H;
//   var ctx = canvas.getContext("2d");


//   var particles = [];
//   var mouse = {};





  

//   // track mouse
//   canvas.addEventListener('mousemove', function(e) {
//     mouse.x = e.pageX;
//     mouse.y = e.pageY;
//   }, false);

//   // create particles
//   var total = 10;
//   for (var i = 0; i < total; i++) {
//     particles.push(new particle(true));
//   }

//   function particle(dead) {
//     var a = Math.PI * 2 * Math.random();
//     this.speed = {
//       x: Math.cos(a) * 2 * speed,
//       y: Math.sin(a) * 2 * speed
//     };

//     // location = mouse coordinates
//     // Now the flame follows the mouse coordinates
//     if (mouse.x && mouse.y && follow) {
//       this.location = {
//         x: mouse.x + -150 + Math.random() * 300,
//         y: mouse.y + -150 + Math.random() * 300
//       };
//     } else {
//       this.location = {
//         x: W / 2,
//         y: H / 2
//       };
//     }

//     // radius range = 10-30
//     this.radius = 2 + Math.random() * 58;
//     if (dead) this.radius = 0;

//     // life range = 1500-5000ms
//     this.time = 1500 + Math.random() * 3500;
//     this.duration = this.time;

//     // color
//     this.r = Math.round(Math.random() * 10);
//     this.b = 150 + Math.round(Math.random() * 10);
//     this.g = 0; Math.round(Math.random()*255);
//   }

//   function draw() {
//     if ((!mouse.x || !mouse.y) && follow_opacity) {
//       window.requestAnimFrame(draw);
//       return;
//     }

//     // clear the canvas with an image:
//     ctx.clearRect(0, 0, W, H);

//     // draw particles:
//     for (var i = 0; i < particles.length; i++) {
//       var p = particles[i];
//       ctx.beginPath();
//       var x = p.location.x,
//         y = p.location.y;
//       var o = Math.linearInOut(p.time, p.duration) * 0.50;
//       if (follow_opacity) {
//         var dx = mouse.x - x;
//         var dy = mouse.y - y;
//         var dist = (Math.sqrt(dx * dx + dy * dy) || 2000);
//         o *= 1 - (dist / 2000);
//       }
//       p.opacity = o != NaN ? o : p.opacity;

//       var gradient = ctx.createRadialGradient(x, y, 0, x, y, p.radius);
//       gradient.addColorStop(0, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
//       gradient.addColorStop(0.8, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
//       gradient.addColorStop(1, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", 0)");
//       ctx.fillStyle = gradient;
//       ctx.arc(p.location.x, p.location.y, p.radius, 0, Math.PI * 2, false);
//       ctx.fill();
//       ctx.closePath();

//       // some basic physics to move and animate the particles
//       p.time -= dt;
//       p.radius -= 0.5;
//       p.location.x += p.speed.x;
//       p.location.y += p.speed.y;

//       // check if the particle has finished:
//       if (p.radius < 0 || p.time < 0) {
//         particles[i] = new particle(); // reset it
//       }
//     }
    

//     window.requestAnimFrame(draw);
//   }

//   window.requestAnimFrame(draw);
// }




// wavey text

$().ready(function () {
  var $e = $('#wave-text');
  wavify($e, -0.2, 12);     
});


function wavify($e, delay, period) {
  var content = $e.text();
  var result = "";
  
  for (var i in content) {
    var c = content[i];
    var s = "";
    
    if (c == ' ') {
      s = "&nbsp;";
    } else {
      var $span = $('<span>')
      .addClass("w")
      .text(c);

      var t = parseFloat(i%period);
      var dt = (1.0 + t) * delay;
      $span.css("-webkit-animation-delay", dt + 's');
      s = $span[0].outerHTML;
    }
    
    result += s;
  }
  
  $e.html(result);
}

 



// BUBBLE SHOOTER

window.requestAnimFrame =
window.requestAnimationFrame       ||
window.webkitRequestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.oRequestAnimationFrame      ||
window.msRequestAnimationFrame     ||
function(callback) {
    window.setTimeout(callback, 4);
};

function Bubble(left, top, num) {
  this.left = left;
  this.top = top;
  this.xAccel = 0;
  this.yAccel = 0;
  this.width = 20;
  this.height = 20;

  this.div = '<div class="bubble" id="bubble-'+num+'"></div>';
  this.cl = ".bubble";
  this.id = "#bubble-" + num;
  this.effect = "wobble";
}

var bubbleNum = 0;

function wobble(ele) {
  ele.addClass('wobble');
  
  setTimeout(function() {
    ele.removeClass('wobble');
  }, 500); 
}

function createBubble() {
  var randY = Math.floor(Math.random() * 8 - 4);
  var randX = Math.floor(Math.random() * 1000);
  var b = new Bubble(40, 150, bubbleNum);
  var that = null;
  var trajX = 5;
  var trajY = randY;
  var curLeft = b.left;
  var curTop = b.top;
  var boundX = $(document).width() - 312;
  var boundY = $(document).height() - 118;

  
  $(b.div).appendTo('.barrel').css({
    top: b.top + 'px',
    left: b.left + 'px'
  });
  
  
  bubbleNum++;
  
  var $thisBubble = $(b.id);
  
  wobble($thisBubble);


  var inc = 0;
  var movingR = true;
  var movingD;
           // Array containing colors

  
  randY <= 0 ? movingD = false : movingD = true; 
  

  
  function floatAround() {
    $thisBubble.css({
      left: curLeft + 'px'
    });
    
    movingR ? curLeft = curLeft + trajX : curLeft = curLeft - trajX;

    if (curLeft > boundX && movingR) {
      wobble($thisBubble);
    }
    else if (curLeft < -312 && !movingR) {
      movingR = true;
      wobble($thisBubble);
    }

    if(bubbleNum == inc++) {
      $thisBubble.css({
        background: '#c44e9d'
      });
    }
  
 
    
    if (inc == 50) {
      $thisBubble.css({
        zIndex: '10'
      });
    }
    
    if (inc % 3 == 0) {
      $thisBubble.css({
        top: curTop + 'px'
      });
      
      if (curTop > boundY && movingD) {
        movingD = false;
        wobble($thisBubble);
      }
      else if (curTop < -90 && !movingD) {
        movingD = true;
        wobble($thisBubble);
      }
      
      if (randY <= 0 && movingD) {
        curTop = curTop - trajY;
      }
      else if (randY > 0 && movingD) {
        curTop = curTop + trajY;
      }
      else if (randY <= 0 && !movingD) {
        curTop = curTop + trajY;
      }
      else if (randY > 0 && !movingD) {
        curTop = curTop - trajY;
      }
    }

    inc++;
    requestAnimFrame(floatAround);
  }
  requestAnimFrame(floatAround);
  
/*  var floating = setInterval(function() {
    
  }, 8)*/
}

$(document).ready(function() {
  
  var barrel;
  var bubbleNum = 0;
  
  $('.barrel').on('mousedown touchstart', function(e) {
    e.preventDefault();
  
    
    $('.barrel h2').fadeOut(300);

    $('.barrel').addClass('shoot');
    
    handle = setInterval(function() {
      createBubble();
    }, 200);
  });
  
  $('.barrel').on('mouseup touchend', function() {
    $('.barrel').removeClass('.barrel');
    
    clearInterval(handle);
    handle = null;
  });
 
  $('body').on('click touchstart', '.bubble', function() {
    $this = $(this);
    $this.addClass('pop');
    
    setTimeout(function() {
      $this.remove();
    }, 100);
  })
  
})





// subscroll

var isScrolling;

// Listen for scroll events
window.addEventListener('scroll', function (  ) {
  $(".wingg").css({
    animation: 'rotate .5s infinite linear' 
  }); 
  $(".bubblee").css({
    opacity: "100%",
    transform:"scale(1.9)"
   }); 

    
    
	// Clear our timeout throughout the scroll
	window.clearTimeout( isScrolling );

	// Set a timeout to run after scrolling ends
	isScrolling = setTimeout(function() {

    // Run the callback

  $(".wingg").css({
  animation: 'rotate 0s infinite linear' 
}); 
$(".bubblee").css({
  opacity: "60%",
}); 

  
  
		console.log( 'Scrolling has stopped.' );
  
  }, 66);
  
  

}, false);





function onVisible(element, callback) {
  new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if(entry.intersectionRatio > 0) {
        callback(element);
        observer.disconnect();
        $(".submarine").css({
          top: '1400px',
          transition: 'all 5s'
        }); 
      }
    });
  }).observe(element); 
} 


onVisible(document.querySelector("#footer"), () => 
console.log("it's visible"));





